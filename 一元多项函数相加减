#include<stdio.h>
#include<stdlib.h>

#define LEN sizeof(Poly)

typedef struct term {
	float coef;  //系数 
	int expn;	 //指数 
	struct term* next;
}Poly, * Link;

void CreatePolyn(Link* p, int m);
void PrintPolyn(Link p);
int cmp(Link p1, Link p2);
Link AddPolyn(Link pa, Link pb);

int main()
{
	Link P1, P2;
	int L1, L2;
	printf("请输入第一个多项式的项数：");
	scanf("%d", &L1);
	CreatePolyn(&P1, L1);
	printf("第一个多项式为：");
	PrintPolyn(P1);
	printf("请输入第二个多项式的项数：");
	scanf("%d", &L2);
	CreatePolyn(&P2, L2);
	printf("第二个多项式为：");
	PrintPolyn(P2);
	printf("\n");
	printf("两个一元多项式相加的结果为：");
	PrintPolyn(AddPolyn(P1, P2));
}

void CreatePolyn(Link* p, int m)//*p是双重指针，用此意在改变指针 
//创建多项式（带头结点），基础：动态链表的创建 
{
	Link r, s;
	int i;
	*p = (Link)malloc(LEN);
	r = *p;
	for (i = 0; i < m; i++)
	{
		s = (Link)malloc(LEN);
		printf("输入系数和指数（以空格隔开）:");
		scanf("%f %d", &s->coef, &s->expn);
		r->next = s;
		r = s;
	}
	r->next = NULL;
}

void PrintPolyn(Link p)
//打印显示多项式，基础：遍历链表 
{
	Link s;
	s = p->next;
	while (s)
	{
		printf("%.2f X^%d", s->coef, s->expn);
		s = s->next;
		if (s != NULL)  //是正数则用'+'连接两项，是负数则直接用负数的负号'-'连接两项 
			if (s->coef >= 0) printf("+");
	}
	printf("\n");
}
int cmp(Link a, Link b)
//比较两项的指数的大小，并返回特定的值。 
{
	if (a->expn < b->expn) return  -1;
	else if (a->expn == b->expn) return  0;
	else return 1;
}
Link AddPolyn(Link pa, Link pb)//pa, pb是两个指向头结点的指针
//两个多项式相加得一个新多项式，并且返回新多项式的头结点的指针  
{
	Link newp, p, q, s, pc;
	float sum;
	p = pa->next; //p指向pa的第一个元素
	q = pb->next; //q指向pb的第一个元素
	newp = (Link)malloc(LEN); //pc指向新多项式pc的头结点
	pc = newp;
	while (p && q) {
		switch (cmp(p, q))
		{
		case -1:   //若指数：p<q,则将p所指结点链入头结点为newp的链表中，且p向后遍历 
			s = (Link)malloc(LEN);
			s->coef = p->coef;
			s->expn = p->expn;
			pc->next = s;
			pc = s;
			p = p->next;
			break;
		case 0://若比较两项的指数相等，则将两项系数相加后得到的项放入头结点为newp的链表中 ，且p,q同时向后遍历 
			sum = p->coef + q->coef;
			if (sum != 0.0)//若两项系数相加为0，则不放入头结点为newp的链表中 
			{
				s = (Link)malloc(LEN);
				s->coef = sum;
				s->expn = p->expn;
				pc->next = s;
				pc = s;
			}
			p = p->next;
			q = q->next;
			break;
		case 1:   //若指数：q<p,则将q所指结点链入头结点为newp的链表中，且q向后遍历 
			s = (Link)malloc(LEN);
			s->coef = q->coef;
			s->expn = q->expn;
			pc->next = s;
			pc = s;
			q = q->next;
			break;
		}
	}
	while (p) //若p所在链表还有剩余项，直接将剩余项依次链入头结点为newp的链表中
	{
		s = (Link)malloc(LEN);
		s->coef = p->coef;
		s->expn = p->expn;
		pc->next = s;
		pc = s;
		p = p->next;
	}
	while (q)//若q所在链表还有剩余项，直接将剩余项依次链入头结点为newp的链表中 
	{
		s = (Link)malloc(LEN);
		s->coef = q->coef;
		s->expn = q->expn;
		pc->next = s;
		pc = s;
		q = q->next;
	}
	pc->next = NULL;
	return newp; //返回新多项式的首地址
}
